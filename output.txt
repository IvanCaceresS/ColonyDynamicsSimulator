1.PrefabMaterialCreator.cs{CPAM_Primitive("SCerevisiae",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(1,0.84f,0,1)); CPAM_Primitive("EColi",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),1,new Color(0.314f,0.784f,0.471f,1)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical("Spirochaeta",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.2f,0.6f,1f,1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale });  if (prefabName == "EColi") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1200f, SeparationThreshold = 0.75f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1200f * 0.75f, TimeSinceLastDivision = 0f, DivisionInterval = 1200f * 0.75f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == "SCerevisiae") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5400f, SeparationThreshold = 0.65f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5400f * 0.65f, TimeSinceLastDivision = 0f, DivisionInterval = 5400f * 0.65f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == "Spirochaeta") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 5400f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 5400f * 0.8f, TimeReference = 5400f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case "EColi": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case "SCerevisiae": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case "Spirochaeta": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 20; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere."); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($"Failed to create physics collider for {prefabName}."); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); } bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength; if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance); if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration; float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f; if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; } if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; } organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true; if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f; uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed); cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1; ecb.SetComponent(entityInQueryIndex, newChildEntity, cd); organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f; float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f; float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg); quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0); transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}