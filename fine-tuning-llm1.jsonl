{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli con forma de bacilo de color azul marino, se duplica cada 25 minutos y el hijo se separa del padre cuando alcanza el 70% del crecimiento. Una S.Serevisiae con forma de cocco de color verde esmeralda, se duplica cada 95 minutos y el hijo se separa del padre cuando alcanza el 35% del crecimiento. Una Spirochaeta con forma de helicoide de color morado oscuro, se duplica cada 50 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(0.0f, 0.0f, 0.502f, 1f)); CPAM_Primitive(\"S.Serevisiae\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(0.314f, 0.784f, 0.471f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.251f, 0.0f, 0.251f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1500.0f, SeparationThreshold = 0.70f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1500.0f * 0.70f, TimeSinceLastDivision = 0f, DivisionInterval = 1500.0f * 0.70f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"S.Serevisiae\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5700.0f, SeparationThreshold = 0.35f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5700.0f * 0.35f, TimeSinceLastDivision = 0f, DivisionInterval = 5700.0f * 0.35f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Spirochaeta\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 3000.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 3000.0f * 0.8f, TimeReference = 3000.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Spirochaeta\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli con forma de bacilo de color celeste, se duplica cada 38 minutos y el hijo se separa del padre cuando alcanza el 40% del crecimiento. Una S.Serevisiae con forma de cocco de color fucsia, se duplica cada 85 minutos y el hijo se separa del padre cuando alcanza el 72% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(0.678f, 0.847f, 0.902f, 1f)); CPAM_Primitive(\"S.Serevisiae\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(1.0f, 0.0f, 1.0f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 2280.0f, SeparationThreshold = 0.40f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 2280.0f * 0.40f, TimeSinceLastDivision = 0f, DivisionInterval = 2280.0f * 0.40f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"S.Serevisiae\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5100.0f, SeparationThreshold = 0.72f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5100.0f * 0.72f, TimeSinceLastDivision = 0f, DivisionInterval = 5100.0f * 0.72f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli con forma de bacilo de color rosado chicle, se duplica cada 21 minutos y el hijo se separa del padre cuando alcanza el 62% del crecimiento. Una Spirochaeta con forma de helicoide de color azul zafiro, se duplica cada 43 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(1.0f, 0.714f, 0.757f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.059f, 0.322f, 0.729f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1260.0f, SeparationThreshold = 0.62f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1260.0f * 0.62f, TimeSinceLastDivision = 0f, DivisionInterval = 1260.0f * 0.62f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"Spirochaeta\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 2580.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 2580.0f * 0.8f, TimeReference = 2580.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"Spirochaeta\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una S.Serevisiae con forma de cocco de color morado berenjena, se duplica cada 92 minutos y el hijo se separa del padre cuando alcanza el 43% del crecimiento. Una Spirochaeta con forma de helicoide de color amarillo sol, se duplica cada 37 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"S.Serevisiae\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(0.38f, 0.239f, 0.38f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.988f, 0.91f, 0.31f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"S.Serevisiae\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5520.0f, SeparationThreshold = 0.43f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5520.0f * 0.43f, TimeSinceLastDivision = 0f, DivisionInterval = 5520.0f * 0.43f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Spirochaeta\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 2220.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 2220.0f * 0.8f, TimeReference = 2220.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"S.Serevisiae\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Spirochaeta\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli_1 con forma de bacilo de color amarillo brillante, se duplica cada 58 minutos y el hijo se separa del padre cuando alcanza el 33% del crecimiento. Una E.Coli_2 con forma de bacilo de color rojo intenso, se duplica cada 23 minutos y el hijo se separa del padre cuando alcanza el 88% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli_1\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(1.0f, 1.0f, 0.0f, 1f)); CPAM_Primitive(\"E.Coli_2\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),1,new Color(1.0f, 0.0f, 0.0f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli_1\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 3480.0f, SeparationThreshold = 0.33f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 3480.0f * 0.33f, TimeSinceLastDivision = 0f, DivisionInterval = 3480.0f * 0.33f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"E.Coli_2\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1380.0f, SeparationThreshold = 0.88f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1380.0f * 0.88f, TimeSinceLastDivision = 0f, DivisionInterval = 1380.0f * 0.88f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli_1\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"E.Coli_2\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una S.Serevisiae_1 con forma de cocco de color verde manzana, se duplica cada 9 minutos (rápido) y el hijo se separa del padre cuando alcanza el 28% del crecimiento. Una S.Serevisiae_2 con forma de cocco de color rosa pastel, se duplica cada 103 minutos y el hijo se separa del padre cuando alcanza el 73% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"S.Serevisiae_1\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(0.549f, 0.859f, 0.188f, 1f)); CPAM_Primitive(\"S.Serevisiae_2\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(0.98f, 0.816f, 0.843f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"S.Serevisiae_1\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 540.0f, SeparationThreshold = 0.28f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 540.0f * 0.28f, TimeSinceLastDivision = 0f, DivisionInterval = 540.0f * 0.28f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"S.Serevisiae_2\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 6180.0f, SeparationThreshold = 0.73f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 6180.0f * 0.73f, TimeSinceLastDivision = 0f, DivisionInterval = 6180.0f * 0.73f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"S.Serevisiae_1\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae_2\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una Spirochaeta_1 con forma de helicoide de color morado intenso, se duplica cada 1 hora y 5 minutos. Una Spirochaeta_2 con forma de helicoide de color café canela, se duplica cada 23 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta_1\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.302f, 0.0f, 0.302f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta_2\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.824f, 0.412f, 0.118f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Spirochaeta_1\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 3900.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 3900.0f * 0.8f, TimeReference = 3900.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } else if (prefabName == \"Spirochaeta_2\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 1380.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 1380.0f * 0.8f, TimeReference = 1380.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Spirochaeta_1\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; case \"Spirochaeta_2\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders_2 = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength_2 = axialLength / colliderSegments; float angularChangePerUnitY_2 = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius_2 = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength_2 * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY_2; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius_2 }, CollisionFilter.Default, physicsMat ); heliColliders_2.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders_2.IsCreated && heliColliders_2.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders_2.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders_2.IsCreated) heliColliders_2.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una S.Serevisiae_1 con forma de cocco de color verde hoja, se duplica cada 93 minutos y el hijo se separa del padre cuando alcanza el 61% del crecimiento. Una S.Serevisiae_2 con forma de cocco de color rosa barbie, se duplica cada 123 minutos y el hijo se separa del padre cuando alcanza el 41% del crecimiento. Una E.Coli con forma de bacilo de color azul rey, se duplica cada 21 minutos y el hijo se separa del padre cuando alcanza el 71% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"S.Serevisiae_1\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(0.298f, 0.569f, 0.298f, 1f)); CPAM_Primitive(\"S.Serevisiae_2\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(0.898f, 0.333f, 0.62f, 1f)); CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),2,new Color(0.255f, 0.412f, 0.882f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"S.Serevisiae_1\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5580.0f, SeparationThreshold = 0.61f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5580.0f * 0.61f, TimeSinceLastDivision = 0f, DivisionInterval = 5580.0f * 0.61f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"S.Serevisiae_2\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 7380.0f, SeparationThreshold = 0.41f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 7380.0f * 0.41f, TimeSinceLastDivision = 0f, DivisionInterval = 7380.0f * 0.41f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1260.0f, SeparationThreshold = 0.71f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1260.0f * 0.71f, TimeSinceLastDivision = 0f, DivisionInterval = 1260.0f * 0.71f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"S.Serevisiae_1\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae_2\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una Spirochaeta_1 con forma de helicoide de color morado real, se duplica cada 42 minutos. Una Spirochaeta_2 con forma de helicoide de color café tabaco, se duplica cada 62 minutos. Una S.Serevisiae con forma de cocco de color verde jade, se duplica cada 94 minutos y el hijo se separa del padre cuando alcanza el 63% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta_1\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.4f, 0.125f, 0.502f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta_2\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.463f, 0.361f, 0.263f, 1f)); CPAM_Primitive(\"S.Serevisiae\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),2,new Color(0.0f, 0.659f, 0.412f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Spirochaeta_1\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 2520.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 2520.0f * 0.8f, TimeReference = 2520.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } else if (prefabName == \"Spirochaeta_2\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 3720.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 3720.0f * 0.8f, TimeReference = 3720.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } else if (prefabName == \"S.Serevisiae\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5640.0f, SeparationThreshold = 0.63f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5640.0f * 0.63f, TimeSinceLastDivision = 0f, DivisionInterval = 5640.0f * 0.63f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Spirochaeta_1\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; case \"Spirochaeta_2\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders_2 = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength_2 = axialLength / colliderSegments; float angularChangePerUnitY_2 = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius_2 = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength_2 * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY_2; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius_2 }, CollisionFilter.Default, physicsMat ); heliColliders_2.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders_2.IsCreated && heliColliders_2.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders_2.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders_2.IsCreated) heliColliders_2.Dispose(); break; case \"S.Serevisiae\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una S.Serevisiae_1 con forma de cocco de color verde oliva, se duplica cada 87 minutos y el hijo se separa del padre cuando alcanza el 56% del crecimiento. Una S.Serevisiae_2 con forma de cocco de color rosa chicle, se duplica cada 117 minutos y el hijo se separa del padre cuando alcanza el 71% del crecimiento. Una Spirochaeta con forma de helicoide de color morado oscuro, se duplica cada 46 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"S.Serevisiae_1\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(0.502f, 0.502f, 0.0f, 1f)); CPAM_Primitive(\"S.Serevisiae_2\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(1.0f, 0.714f, 0.757f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.251f, 0.0f, 0.251f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"S.Serevisiae_1\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5220.0f, SeparationThreshold = 0.56f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5220.0f * 0.56f, TimeSinceLastDivision = 0f, DivisionInterval = 5220.0f * 0.56f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"S.Serevisiae_2\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 7020.0f, SeparationThreshold = 0.71f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 7020.0f * 0.71f, TimeSinceLastDivision = 0f, DivisionInterval = 7020.0f * 0.71f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Spirochaeta\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 2760.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 2760.0f * 0.8f, TimeReference = 2760.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"S.Serevisiae_1\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae_2\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Spirochaeta\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una Spirochaeta_1 con forma de helicoide de color morado eléctrico, se duplica cada 51 minutos. Una Spirochaeta_2 con forma de helicoide de color café latte, se duplica cada 26 minutos. Una E.Coli con forma de bacilo de color azul océano, se duplica cada 23 minutos y el hijo se separa del padre cuando alcanza el 64% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta_1\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.749f, 0.0f, 1.0f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta_2\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.757f, 0.627f, 0.494f, 1f)); CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),2,new Color(0.0f, 0.498f, 0.753f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Spirochaeta_1\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 3060.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 3060.0f * 0.8f, TimeReference = 3060.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } else if (prefabName == \"Spirochaeta_2\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 1560.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 1560.0f * 0.8f, TimeReference = 1560.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } else if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1380.0f, SeparationThreshold = 0.64f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1380.0f * 0.64f, TimeSinceLastDivision = 0f, DivisionInterval = 1380.0f * 0.64f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Spirochaeta_1\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; case \"Spirochaeta_2\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders_2 = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength_2 = axialLength / colliderSegments; float angularChangePerUnitY_2 = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius_2 = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength_2 * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY_2; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius_2 }, CollisionFilter.Default, physicsMat ); heliColliders_2.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders_2.IsCreated && heliColliders_2.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders_2.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders_2.IsCreated) heliColliders_2.Dispose(); break; case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli_1 con forma de bacilo de color amarillo canario, se duplica cada 62 minutos y el hijo se separa del padre cuando alcanza el 31% del crecimiento. Una E.Coli_2 con forma de bacilo de color rojo cereza, se duplica cada 24 minutos y el hijo se separa del padre cuando alcanza el 92% del crecimiento. Una Spirochaeta con forma de helicoide de color morado berenjena, se duplica cada 41 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli_1\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(1.0f, 0.937f, 0.0f, 1f)); CPAM_Primitive(\"E.Coli_2\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),1,new Color(0.867f, 0.11f, 0.29f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.38f, 0.239f, 0.38f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli_1\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 3720.0f, SeparationThreshold = 0.31f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 3720.0f * 0.31f, TimeSinceLastDivision = 0f, DivisionInterval = 3720.0f * 0.31f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"E.Coli_2\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1440.0f, SeparationThreshold = 0.92f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1440.0f * 0.92f, TimeSinceLastDivision = 0f, DivisionInterval = 1440.0f * 0.92f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"Spirochaeta\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 2460.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 2460.0f * 0.8f, TimeReference = 2460.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli_1\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"E.Coli_2\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"Spirochaeta\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli_1 con forma de bacilo de color amarillo limón, se duplica cada 57 minutos y el hijo se separa del padre cuando alcanza el 36% del crecimiento. Una E.Coli_2 con forma de bacilo de color rojo pasión, se duplica cada 21 minutos y el hijo se separa del padre cuando alcanza el 87% del crecimiento. Una S.Serevisiae con forma de cocco de color verde esmeralda, se duplica cada 92 minutos y el hijo se separa del padre cuando alcanza el 62% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli_1\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(1.0f, 0.98f, 0.973f, 1f)); CPAM_Primitive(\"E.Coli_2\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),1,new Color(0.784f, 0.0f, 0.216f, 1f)); CPAM_Primitive(\"S.Serevisiae\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),2,new Color(0.314f, 0.784f, 0.471f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli_1\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 3420.0f, SeparationThreshold = 0.36f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 3420.0f * 0.36f, TimeSinceLastDivision = 0f, DivisionInterval = 3420.0f * 0.36f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"E.Coli_2\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1260.0f, SeparationThreshold = 0.87f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1260.0f * 0.87f, TimeSinceLastDivision = 0f, DivisionInterval = 1260.0f * 0.87f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"S.Serevisiae\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5520.0f, SeparationThreshold = 0.62f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5520.0f * 0.62f, TimeSinceLastDivision = 0f, DivisionInterval = 5520.0f * 0.62f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli_1\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"E.Coli_2\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}6.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}7.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli con forma de bacilo de color azul Francia, se duplica cada 23 minutos y el hijo se separa del padre cuando alcanza el 69% del crecimiento. Un Streptococcus con forma de cocco (en cadenas) de color rojo Ferrari, se duplica cada 28 minutos y el hijo se separa del padre cuando alcanza el 62% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(0.192f, 0.549f, 0.906f, 1f)); CPAM_Primitive(\"Streptococcus\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(1.0f, 0.11f, 0.0f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1380.0f, SeparationThreshold = 0.69f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1380.0f * 0.69f, TimeSinceLastDivision = 0f, DivisionInterval = 1380.0f * 0.69f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"Streptococcus\") { entityManager.AddComponentData(newEntity, new StreptococcusComponent { TimeReference = 1680.0f, SeparationThreshold = 0.62f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 1680.0f * 0.62f, TimeSinceLastDivision = 0f, DivisionInterval = 1680.0f * 0.62f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"Streptococcus\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}6.StreptococcusComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct StreptococcusComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}8.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}11.StreptococcusSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref StreptococcusComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; StreptococcusComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli con forma de bacilo de color rojo amapola, se duplica cada 27 minutos y el hijo se separa del padre cuando alcanza el 63% del crecimiento. Una Pseudomonas con forma de bacilo de color verde fluorescente brillante, se duplica cada 32 minutos y el hijo se separa del padre cuando alcanza el 72% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(0.863f, 0.078f, 0.235f, 1f)); CPAM_Primitive(\"Pseudomonas\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),1,new Color(0.29f, 1.0f, 0.0f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1620.0f, SeparationThreshold = 0.63f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1620.0f * 0.63f, TimeSinceLastDivision = 0f, DivisionInterval = 1620.0f * 0.63f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"Pseudomonas\") { entityManager.AddComponentData(newEntity, new PseudomonasComponent { TimeReference = 1920.0f, SeparationThreshold = 0.72f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1920.0f * 0.72f, TimeSinceLastDivision = 0f, DivisionInterval = 1920.0f * 0.72f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"Pseudomonas\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}7.PseudomonasComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct PseudomonasComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}8.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}12.PseudomonasSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref PseudomonasComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; PseudomonasComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Un Streptococcus_1 con forma de cocco (en cadenas) de color rojo carmesí, se duplica cada 22 minutos y el hijo se separa del padre cuando alcanza el 61% del crecimiento. Un Streptococcus_2 con forma de cocco (en cadenas) de color azul cobalto, se duplica cada 33 minutos y el hijo se separa del padre cuando alcanza el 71% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"Streptococcus_1\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(0.863f, 0.078f, 0.235f, 1f)); CPAM_Primitive(\"Streptococcus_2\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(0.0f, 0.278f, 0.675f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Streptococcus_1\") { entityManager.AddComponentData(newEntity, new StreptococcusComponent { TimeReference = 1320.0f, SeparationThreshold = 0.61f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 1320.0f * 0.61f, TimeSinceLastDivision = 0f, DivisionInterval = 1320.0f * 0.61f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Streptococcus_2\") { entityManager.AddComponentData(newEntity, new StreptococcusComponent { TimeReference = 1980.0f, SeparationThreshold = 0.71f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 1980.0f * 0.71f, TimeSinceLastDivision = 0f, DivisionInterval = 1980.0f * 0.71f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Streptococcus_1\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Streptococcus_2\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}6.StreptococcusComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct StreptococcusComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}11.StreptococcusSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref StreptococcusComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; StreptococcusComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una Pseudomonas_1 con forma de bacilo de color verde fluorescente intenso, se duplica cada 26 minutos y el hijo se separa del padre cuando alcanza el 66% del crecimiento. Una Pseudomonas_2 con forma de bacilo de color azul verdoso pálido, se duplica cada 36 minutos y el hijo se separa del padre cuando alcanza el 56% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"Pseudomonas_1\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(0.1f, 1.0f, 0.1f, 1f)); CPAM_Primitive(\"Pseudomonas_2\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),1,new Color(0.6f, 0.8f, 0.75f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Pseudomonas_1\") { entityManager.AddComponentData(newEntity, new PseudomonasComponent { TimeReference = 1560.0f, SeparationThreshold = 0.66f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1560.0f * 0.66f, TimeSinceLastDivision = 0f, DivisionInterval = 1560.0f * 0.66f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"Pseudomonas_2\") { entityManager.AddComponentData(newEntity, new PseudomonasComponent { TimeReference = 2160.0f, SeparationThreshold = 0.56f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 2160.0f * 0.56f, TimeSinceLastDivision = 0f, DivisionInterval = 2160.0f * 0.56f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Pseudomonas_1\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"Pseudomonas_2\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}7.PseudomonasComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct PseudomonasComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}12.PseudomonasSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref PseudomonasComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; PseudomonasComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli con forma de bacilo de color azul marino, se duplica cada 22 minutos y el hijo se separa del padre cuando alcanza el 62% del crecimiento. Una S.Serevisiae con forma de cocco de color verde pino, se duplica cada 93 minutos y el hijo se separa del padre cuando alcanza el 52% del crecimiento. Un Streptococcus con forma de cocco (en cadenas) de color rojo brillante, se duplica cada 27 minutos y el hijo se separa del padre cuando alcanza el 72% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(0.0f, 0.0f, 0.502f, 1f)); CPAM_Primitive(\"S.Serevisiae\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(0.004f, 0.302f, 0.2f, 1f)); CPAM_Primitive(\"Streptococcus\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),2,new Color(1.0f, 0.0f, 0.0f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1320.0f, SeparationThreshold = 0.62f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1320.0f * 0.62f, TimeSinceLastDivision = 0f, DivisionInterval = 1320.0f * 0.62f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"S.Serevisiae\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 5580.0f, SeparationThreshold = 0.52f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 5580.0f * 0.52f, TimeSinceLastDivision = 0f, DivisionInterval = 5580.0f * 0.52f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Streptococcus\") { entityManager.AddComponentData(newEntity, new StreptococcusComponent { TimeReference = 1620.0f, SeparationThreshold = 0.72f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 1620.0f * 0.72f, TimeSinceLastDivision = 0f, DivisionInterval = 1620.0f * 0.72f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Streptococcus\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}6.StreptococcusComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct StreptococcusComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}8.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}9.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}11.StreptococcusSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref StreptococcusComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; StreptococcusComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una E.Coli con forma de bacilo de color naranja neón, se duplica cada 28 minutos y el hijo se separa del padre cuando alcanza el 67% del crecimiento. Una S.Serevisiae con forma de cocco de color celeste aguamarina, se duplica cada 83 minutos y el hijo se separa del padre cuando alcanza el 53% del crecimiento. Una Pseudomonas con forma de bacilo de color verde fluorescente puro, se duplica cada 33 minutos y el hijo se separa del padre cuando alcanza el 71% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"E.Coli\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(1.0f, 0.627f, 0.2f, 1f)); CPAM_Primitive(\"S.Serevisiae\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),1,new Color(0.498f, 1.0f, 0.831f, 1f)); CPAM_Primitive(\"Pseudomonas\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),2,new Color(0.0f, 1.0f, 0.0f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"E.Coli\") { entityManager.AddComponentData(newEntity, new EColiComponent { TimeReference = 1680.0f, SeparationThreshold = 0.67f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1680.0f * 0.67f, TimeSinceLastDivision = 0f, DivisionInterval = 1680.0f * 0.67f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"S.Serevisiae\") { entityManager.AddComponentData(newEntity, new SCerevisiaeComponent { TimeReference = 4980.0f, SeparationThreshold = 0.53f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 4980.0f * 0.53f, TimeSinceLastDivision = 0f, DivisionInterval = 4980.0f * 0.53f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Pseudomonas\") { entityManager.AddComponentData(newEntity, new PseudomonasComponent { TimeReference = 1980.0f, SeparationThreshold = 0.71f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1980.0f * 0.71f, TimeSinceLastDivision = 0f, DivisionInterval = 1980.0f * 0.71f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"E.Coli\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"S.Serevisiae\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Pseudomonas\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}3.EColiComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct EColiComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}4.SCerevisiaeComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SCerevisiaeComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}7.PseudomonasComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct PseudomonasComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}8.EColiSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref EColiComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; EColiComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}9.SCerevisiaeSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SCerevisiaeComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; SCerevisiaeComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}12.PseudomonasSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref PseudomonasComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; PseudomonasComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Un Streptococcus con forma de cocco (en cadenas) de color rojo sangre arterial, se duplica cada 23 minutos y el hijo se separa del padre cuando alcanza el 63% del crecimiento. Una Spirochaeta con forma de helicoide de color azul medianoche, se duplica cada 44 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"Streptococcus\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(0.929f, 0.11f, 0.141f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.098f, 0.098f, 0.439f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Streptococcus\") { entityManager.AddComponentData(newEntity, new StreptococcusComponent { TimeReference = 1380.0f, SeparationThreshold = 0.63f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 1380.0f * 0.63f, TimeSinceLastDivision = 0f, DivisionInterval = 1380.0f * 0.63f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Spirochaeta\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 2640.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 2640.0f * 0.8f, TimeReference = 2640.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Streptococcus\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Spirochaeta\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}6.StreptococcusComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct StreptococcusComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}11.StreptococcusSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref StreptococcusComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; StreptococcusComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Una Pseudomonas con forma de bacilo de color verde fluorescente eléctrico, se duplica cada 28 minutos y el hijo se separa del padre cuando alcanza el 73% del crecimiento. Una Spirochaeta con forma de helicoide de color rojo cereza oscuro, se duplica cada 38 minutos."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"Pseudomonas\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),0,new Color(0.2f, 1.0f, 0.2f, 1f)); float length=10f, helixR=0.5f, tubeR=0.1f, turns=3f; int helixSegments=30, tubeSegments=8; CPAM_Helical(\"Spirochaeta\",length, helixR, tubeR, helixSegments, tubeSegments, turns, new Vector3(90,0,0), new Color(0.6f, 0.08f, 0.2f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Pseudomonas\") { entityManager.AddComponentData(newEntity, new PseudomonasComponent { TimeReference = 1680.0f, SeparationThreshold = 0.73f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1680.0f * 0.73f, TimeSinceLastDivision = 0f, DivisionInterval = 1680.0f * 0.73f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } else if (prefabName == \"Spirochaeta\") { entityManager.AddComponentData(newEntity, new SpirochaetaComponent { MaxAxialLength = 10f, CurrentAxialLength = 10f / 2f, GrowthTime = 0f, GrowthDuration = 2280.0f * 0.8f, TimeSinceLastDivision = 0f, DivisionInterval = 2280.0f * 0.8f, TimeReference = 2280.0f, IsInitialCell = true, TimeReferenceInitialized = false }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Pseudomonas\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; case \"Spirochaeta\": const float axialLength = 10f; const float helixRadius = 0.5f; const float tubeRadius = 0.1f; const float turns = 3f; const int colliderSegments = 14; NativeList<CompoundCollider.ColliderBlobInstance> heliColliders = new NativeList<CompoundCollider.ColliderBlobInstance>(colliderSegments, Allocator.Temp); float segmentLength = axialLength / colliderSegments; float angularChangePerUnitY = (axialLength > 0) ? (turns * 2 * Mathf.PI / axialLength) : 0f; float subColliderActualRadius = tubeRadius; for (int i = 0; i < colliderSegments; i++) { float yPos = -axialLength / 2.0f + segmentLength * (i + 0.5f); float helixAngleAtY = yPos * angularChangePerUnitY; float3 sphereCenter = new float3( helixRadius * math.cos(helixAngleAtY), yPos, helixRadius * math.sin(helixAngleAtY) ); BlobAssetReference<Unity.Physics.Collider> sphereBlob = Unity.Physics.SphereCollider.Create( new SphereGeometry { Center = float3.zero, Radius = subColliderActualRadius }, CollisionFilter.Default, physicsMat ); heliColliders.Add(new CompoundCollider.ColliderBlobInstance { Collider = sphereBlob, CompoundFromChild = new RigidTransform(quaternion.identity, sphereCenter) }); }  if (heliColliders.IsCreated && heliColliders.Length > 0) colliderAsset = Unity.Physics.CompoundCollider.Create(heliColliders.AsArray()); else { colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry{ Vertex0 = new float3(0, -axialLength/2f, 0), Vertex1 = new float3(0, axialLength/2f, 0), Radius = helixRadius + tubeRadius }, CollisionFilter.Default, physicsMat); } if(heliColliders.IsCreated) heliColliders.Dispose(); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}5.SpirochaetaComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct SpirochaetaComponent:IComponentData { public float CurrentAxialLength,MaxAxialLength,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,TimeReference,ForwardSpeed; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; public Unity.Mathematics.Random RandomState; }}7.PseudomonasComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct PseudomonasComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}8.SpirochaetaSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref SpirochaetaComponent organism)=> { if (organism.RandomState.state == 0) { uint seed = (uint)(entity.Index ^ (entity.Version << 16) ^ entityInQueryIndex) + (uint)(elapsedTimeForSeed * 1000.0f) + 1; organism.RandomState = new Unity.Mathematics.Random(seed == 0 ? 1u : seed); }  bool isChild = organism.Parent != Entity.Null; if (!isChild && organism.IsInitialCell && !organism.TimeReferenceInitialized) { float randomMultiplier = organism.RandomState.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; }  if (isChild) { bool childIsActivelySeparating = organism.CurrentAxialLength < organism.MaxAxialLength;  if (childIsActivelySeparating) { if (organism.ForwardSpeed > 0.00001f) { float distanceToMoveThisFrame = organism.ForwardSpeed * deltaTime; float remainingDistance = organism.MaxAxialLength - organism.CurrentAxialLength; float actualDistanceMovedThisFrame = math.min(distanceToMoveThisFrame, remainingDistance);  if (actualDistanceMovedThisFrame > 0.00001f) organism.CurrentAxialLength += actualDistanceMovedThisFrame; else if (remainingDistance <= 0.00001f && remainingDistance >= 0f) organism.CurrentAxialLength = organism.MaxAxialLength; } if (organism.CurrentAxialLength >= organism.MaxAxialLength) { organism.CurrentAxialLength = organism.MaxAxialLength; organism.ForwardSpeed = 0f; childIsActivelySeparating = false; } } if (parentMap.TryGetValue(organism.Parent, out ParentData parentInfo)) { float3 parentLocalYAxis = new float3(0f, 1f, 0f); float3 separationAxisInWorld = math.mul(parentInfo.Rotation, parentLocalYAxis); transform.Position = parentInfo.Position + (separationAxisInWorld * organism.SeparationSign * organism.CurrentAxialLength); transform.Rotation = parentInfo.Rotation; } if (!childIsActivelySeparating && organism.Parent != Entity.Null) { organism.Parent = Entity.Null; organism.TimeSinceLastDivision = 0f; organism.IsInitialCell = false; organism.GrowthTime = organism.GrowthDuration;  float randomMultiplier = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplier; organism.TimeReferenceInitialized = true; } } else { bool parentIsWaitingOrJustDivided = false; if (!organism.IsInitialCell) parentIsWaitingOrJustDivided = organism.GrowthTime < organism.GrowthDuration && organism.GrowthDuration > 0.001f;  if (organism.ForwardSpeed > 0.0001f && !parentIsWaitingOrJustDivided) { float3 parentLocalUp = new float3(0f, 1f, 0f); float3 worldMoveDirection = math.mul(transform.Rotation, parentLocalUp); transform.Position += worldMoveDirection * organism.ForwardSpeed * deltaTime; }  if (parentIsWaitingOrJustDivided) { organism.GrowthTime += deltaTime; if (organism.GrowthTime >= organism.GrowthDuration) organism.GrowthTime = organism.GrowthDuration; }  organism.TimeSinceLastDivision += deltaTime; bool canDivide = false; float currentDivisionThreshold = organism.IsInitialCell ? organism.TimeReference : organism.DivisionInterval; if (organism.TimeSinceLastDivision >= currentDivisionThreshold && !parentIsWaitingOrJustDivided && currentDivisionThreshold > 0) canDivide = true;  if (canDivide) { Entity newChildEntity = ecb.Instantiate(entityInQueryIndex, entity); LocalTransform childTransform = new LocalTransform { Position = transform.Position, Rotation = transform.Rotation, Scale = transform.Scale }; ecb.SetComponent(entityInQueryIndex, newChildEntity, childTransform);  SpirochaetaComponent cd = organism; cd.Parent = entity; cd.IsInitialCell = false; cd.TimeSinceLastDivision = 0f; cd.TimeReferenceInitialized = true; cd.CurrentAxialLength = 0f; cd.GrowthTime = 0f; cd.ForwardSpeed = 0.3f;  uint childSeed = (uint)(entity.Index ^ entity.Version ^ entityInQueryIndex ^ organism.RandomState.NextUInt()) + (uint)(elapsedTimeForSeed * 1000.0f) + 2; cd.RandomState = new Unity.Mathematics.Random(childSeed == 0 ? 1u : childSeed);  cd.SeparationSign = cd.RandomState.NextBool() ? 1 : -1;  ecb.SetComponent(entityInQueryIndex, newChildEntity, cd);  organism.TimeSinceLastDivision = 0f; organism.GrowthTime = 0f;  float randomMultiplierForParentInterval; if (organism.IsInitialCell) { organism.IsInitialCell = false; randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } else { randomMultiplierForParentInterval = organism.RandomState.NextFloat(0.90f, 1.10f); organism.DivisionInterval = organism.DivisionInterval * randomMultiplierForParentInterval; } } } float maxVibrationAngleDeg = 1.0f;  float randomAngleDeg = organism.RandomState.NextFloat(-maxVibrationAngleDeg, maxVibrationAngleDeg); float randomAngleRad = math.radians(randomAngleDeg);  quaternion localYVibration = quaternion.Euler(0, randomAngleRad, 0);  transform.Rotation = math.mul(transform.Rotation, localYVibration); transform.Position.y = math.max(transform.Position.y, -0.3f);  }).ScheduleParallel(Dependency);}12.PseudomonasSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref PseudomonasComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; PseudomonasComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}
{"messages": [{"role": "system", "content": "Eres un modelo especializado en generar código C# para simulaciones de Unity. Considera que los tiempos son en segundos; además, los colores en Unity se expresan en valores RGB divididos en 255. Debes contestar tal cual como se te fue entrenado, sin agregar nada más de lo que se espera en C#. No puedes responder en ningún otro lenguaje de programación ni añadir comentarios o palabras innecesarias. Solo puedes responder a consultas relacionadas con simulaciones en Unity sobre Bacilos, Cocos o Helicoides, o cualquier combinación de hasta 4 organismos que pertenezcan a estas morfologías. Para cada organismo, se deben indicar: - El color de la(s) célula(s). - El tiempo de duplicación en minutos. - El porcentaje de crecimiento para separarse del padre (solo para Bacilos y Cocos). Tu respuesta debe incluir estrictamente estos scripts en el orden especificado: 1.PrefabMaterialCreator.cs, 2.CreatePrefabsOnClick.cs. Luego, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]Component.cs en el orden en que fue mencionado en la solicitud original. Finalmente, para cada organismo solicitado (hasta 4), se listará su [NombreOrganismo]System.cs en el mismo orden que sus componentes. Cualquier pregunta que no cumpla con las características anteriores (ej. no especifica morfología, supera el límite de 4 organismos, incluye fenómenos no biológicos) será respondida con: \"ERROR FORMATO DE PREGUNTA.\". Siempre asegurate que en tu respuesta esten el siguiente formato los primeros dos scripts seguidos de los scripts component y system de los organismos \"1.PrefabMaterialCreator.cs{...}2.CreatePrefabsOnClick.cs{...}3.[NombreOrganismo]Component.cs{...}4.[NombreOrganismo]System.cs{...}5.[NombreOrganismo2]Component.cs{...}6.[NombreOrganismo2]System.cs{...}\" etc. Considera también que dentro de CreatePrefabsOnClick.cs siempre habran 2 funciones(CreateSingleEntity y AddPhysicsComponents)"},{"role": "user","content": "Un Streptococcus con forma de cocco (en cadenas) de color rojo escarlata brillante, se duplica cada 24 minutos y el hijo se separa del padre cuando alcanza el 61% del crecimiento. Una Pseudomonas con forma de bacilo de color verde lima fluorescente, se duplica cada 29 minutos y el hijo se separa del padre cuando alcanza el 72% del crecimiento."},{"role": "assistant","content": "1.PrefabMaterialCreator.cs{CPAM_Primitive(\"Streptococcus\",PrimitiveType.Sphere,new Vector3(5,5,5),new Vector3(90,0,0),0,new Color(1.0f, 0.137f, 0.0f, 1f)); CPAM_Primitive(\"Pseudomonas\",PrimitiveType.Capsule,new Vector3(0.5f,1,0.5f),new Vector3(90,0,0),1,new Color(0.196f, 1.0f, 0.196f, 1f));}2.CreatePrefabsOnClick.cs{private void CreateSingleEntity(string prefabName, Entity bakedPrefabEntityToInstantiate, Vector3 spawnWorldPosition, quaternion desiredWorldRotation, float originalPrefabScale) { quaternion originalPrefabRotation = entityManager.GetComponentData<LocalTransform>(bakedPrefabEntityToInstantiate).Rotation; quaternion newCombinedRotation = math.mul(originalPrefabRotation, desiredWorldRotation); Entity newEntity = entityManager.Instantiate(bakedPrefabEntityToInstantiate); entityManager.SetComponentData(newEntity, new LocalTransform { Position = (float3)spawnWorldPosition, Rotation = newCombinedRotation, Scale = originalPrefabScale }); if (prefabName == \"Streptococcus\") { entityManager.AddComponentData(newEntity, new StreptococcusComponent { TimeReference = 1440.0f, SeparationThreshold = 0.61f, MaxScale = 5f, GrowthTime = 0f, GrowthDuration = 1440.0f * 0.61f, TimeSinceLastDivision = 0f, DivisionInterval = 1440.0f * 0.61f, Parent = Entity.Null, IsInitialCell = true,TimeReferenceInitialized = false,GrowthDirection = float3.zero }); } else if (prefabName == \"Pseudomonas\") { entityManager.AddComponentData(newEntity, new PseudomonasComponent { TimeReference = 1740.0f, SeparationThreshold = 0.72f, MaxScale = 1f, GrowthTime = 0f, GrowthDuration = 1740.0f * 0.72f, TimeSinceLastDivision = 0f, DivisionInterval = 1740.0f * 0.72f, HasGeneratedChild = false, Parent = Entity.Null, IsInitialCell = true, SeparationSign = 0, TimeReferenceInitialized = false }); if (entityManager.HasComponent<NonUniformScale>(bakedPrefabEntityToInstantiate)) entityManager.SetComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); else entityManager.AddComponentData(newEntity, new NonUniformScale { Value = new float3(.5f, 1f, .5f) }); } AddPhysicsComponents(newEntity, prefabName, originalPrefabScale); }  private void AddPhysicsComponents(Entity e, string prefabName, float scale) { BlobAssetReference<Unity.Physics.Collider> colliderAsset = default; PhysicsMaterial physicsMat = default; physicsMat.Restitution = 0f;  switch (prefabName) { case \"Streptococcus\": colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; case \"Pseudomonas\": colliderAsset = Unity.Physics.CapsuleCollider.Create(new CapsuleGeometry { Vertex0 = new float3(0, -scale * 0.5f, 0), Vertex1 = new float3(0, scale * 0.5f, 0), Radius = scale * 0.25f }, CollisionFilter.Default, physicsMat); break; default: Debug.LogWarning($\"AddPhysicsComponents: No specific collider defined for {prefabName}. Using default sphere.\"); colliderAsset = Unity.Physics.SphereCollider.Create(new SphereGeometry { Center = float3.zero, Radius = scale * 0.1f }, CollisionFilter.Default, physicsMat); break; }  if (colliderAsset.IsCreated) { entityManager.AddComponentData(e, new PhysicsCollider { Value = colliderAsset }); var massProperties = colliderAsset.Value.MassProperties; entityManager.AddComponentData(e, PhysicsMass.CreateDynamic(massProperties, 1f)); entityManager.AddComponentData(e, new PhysicsVelocity { Linear = float3.zero, Angular = float3.zero }); entityManager.AddComponentData(e, new PhysicsGravityFactor { Value = 1f }); entityManager.AddComponentData(e, new PhysicsDamping { Linear = 0.05f, Angular = 0.05f }); } else Debug.LogError($\"Failed to create physics collider for {prefabName}.\"); }}6.StreptococcusComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct StreptococcusComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool IsInitialCell,TimeReferenceInitialized; public Entity Parent; public float3 GrowthDirection; }}7.PseudomonasComponent.cs{using Unity.Entities; using Unity.Mathematics; public struct PseudomonasComponent:IComponentData { public float TimeReference,MaxScale,GrowthTime,GrowthDuration,TimeSinceLastDivision,DivisionInterval,SeparationThreshold; public bool HasGeneratedChild,IsInitialCell,TimeReferenceInitialized; public Entity Parent; public int SeparationSign; }}11.StreptococcusSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref StreptococcusComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*99999); float angle=rng.NextFloat(0f,math.PI*2f); float3 rnd=new float3(math.cos(angle),math.sin(angle),0f); Entity child=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; StreptococcusComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.IsInitialCell=false; cd.Parent=entity; cd.GrowthDirection=rnd; ct.Position=transform.Position; ecb.SetComponent(entityInQueryIndex,child,ct); ecb.SetComponent(entityInQueryIndex,child,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,organism.GrowthDirection); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}12.PseudomonasSystem.cs{Dependency=Entities.WithReadOnly(parentMap).ForEach((Entity entity,int entityInQueryIndex,ref LocalTransform transform,ref PseudomonasComponent organism)=> { if (!organism.TimeReferenceInitialized) { Unity.Mathematics.Random rng = new Unity.Mathematics.Random((uint)(entityInQueryIndex + 1) * 99999); float randomMultiplier = rng.NextFloat(0.9f, 1.1f); organism.TimeReference *= randomMultiplier; organism.TimeReferenceInitialized = true; } float maxScale=organism.MaxScale; organism.GrowthDuration=organism.DivisionInterval=organism.TimeReference*organism.SeparationThreshold; if(transform.Scale<maxScale) { organism.GrowthTime+=deltaTime; float t=math.clamp(organism.GrowthTime/organism.GrowthDuration,0f,1f); float initialScale=organism.IsInitialCell?maxScale:0.01f; transform.Scale=math.lerp(initialScale,maxScale,t);}  if(transform.Scale>=maxScale) { organism.TimeSinceLastDivision+=deltaTime; if(organism.TimeSinceLastDivision>=organism.DivisionInterval) { Unity.Mathematics.Random rng=new Unity.Mathematics.Random((uint)(entityInQueryIndex+1)*12345); int s=rng.NextFloat()<0.5f?1:-1; Entity c=ecb.Instantiate(entityInQueryIndex,entity); LocalTransform ct=transform; ct.Scale=0.01f; PseudomonasComponent cd=organism; cd.TimeReferenceInitialized=false; cd.GrowthTime=0f; cd.TimeSinceLastDivision=0f; cd.HasGeneratedChild=false; cd.Parent=entity; cd.IsInitialCell=false; cd.SeparationSign=s; float3 u=math.mul(transform.Rotation,new float3(0,s,0)); ct.Position=transform.Position+u*(transform.Scale*0.25f); ecb.SetComponent(entityInQueryIndex,c,ct); ecb.SetComponent(entityInQueryIndex,c,cd); organism.TimeSinceLastDivision=0f; } } if(!organism.IsInitialCell&&organism.Parent!=Entity.Null&&parentMap.TryGetValue(organism.Parent,out ParentData pd)) { if(transform.Scale<organism.SeparationThreshold*maxScale) { float sp=math.smoothstep(0f,1f,math.clamp(transform.Scale/(organism.SeparationThreshold*maxScale),0f,1f)); float off=math.lerp(0f,0.9f+organism.SeparationThreshold,sp); float3 sd=math.mul(pd.Rotation,new float3(0,organism.SeparationSign,0)); transform.Position=pd.Position+sd*off; transform.Rotation=pd.Rotation; ecb.SetComponent(entityInQueryIndex,entity,new PhysicsVelocity { Linear=float3.zero,Angular=float3.zero } ); } else organism.Parent=Entity.Null; } ecb.SetComponent(entityInQueryIndex, entity, transform); ecb.SetComponent(entityInQueryIndex, entity, organism); }).ScheduleParallel(Dependency);}"}]}